#!/usr/bin/env bash

set -euo pipefail

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/passonym"
MAPPINGS_FILE="$CONFIG_DIR/mappings.json"
STATE_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/passonym"
LINKS_FILE="$STATE_DIR/links"
PASSWORD_STORE_DIR="${PASSWORD_STORE_DIR:-$HOME/.password-store}"

# Initialization

ensure_config_exists() {
    mkdir -p "$CONFIG_DIR"
    if [[ ! -f "$MAPPINGS_FILE" ]]; then
        echo '{}' > "$MAPPINGS_FILE"
    fi
}

ensure_state_exists() {
    mkdir -p "$STATE_DIR"
    touch "$LINKS_FILE"
}

# Mapping functions

map_add() {
    local real_path="$1"
    local alias="$2"
    ensure_config_exists
    local updated
    updated=$(jq --arg path "$real_path" --arg alias "$alias" '.[$path] = $alias' "$MAPPINGS_FILE")
    echo "$updated" > "$MAPPINGS_FILE"
    echo "Added mapping: $real_path -> $alias"
}

map_remove() {
    local alias="$1"
    ensure_config_exists
    local real_path
    real_path=$(jq -r --arg alias "$alias" 'to_entries[] | select(.value == $alias) | .key' "$MAPPINGS_FILE")
    if [[ -z "$real_path" ]]; then
        echo "No mapping found for alias: $alias" >&2
        return 1
    fi
    local updated
    updated=$(jq --arg path "$real_path" 'del(.[$path])' "$MAPPINGS_FILE")
    echo "$updated" > "$MAPPINGS_FILE"
    echo "Removed mapping: $real_path -> $alias"
}

map_list() {
    ensure_config_exists
    if [[ $(jq 'length' "$MAPPINGS_FILE") -eq 0 ]]; then
        echo "No mappings defined"
        return 0
    fi
    jq -r 'to_entries[] | "\(.key) -> \(.value)"' "$MAPPINGS_FILE"
}

get_mappings() {
    ensure_config_exists
    jq -r 'to_entries[] | "\(.key)\t\(.value)"' "$MAPPINGS_FILE"
}

# Link functions

link_create() {
    local dry_run="${1:-false}"
    ensure_config_exists
    ensure_state_exists
    local linked=0

    while IFS=$'\t' read -r real_path alias; do
        while IFS= read -r -d '' source; do
            local rel_source="${source#$PASSWORD_STORE_DIR/}"
            local rel_target="${rel_source/$real_path/$alias}"
            local target="$PASSWORD_STORE_DIR/$rel_target"

            if [[ "$rel_source" == "$rel_target" ]]; then
                continue
            fi

            if [[ -e "$target" && ! -L "$target" ]]; then
                echo "Warning: Target exists and is not a symlink: $target" >&2
                continue
            fi

            local relative_source
            relative_source=$(realpath -m --relative-to="$(dirname "$target")" "$source")

            if [[ "$dry_run" == "true" ]]; then
                echo "[dry-run] $rel_target -> $relative_source"
            else
                mkdir -p "$(dirname "$target")"
                ln -sf "$relative_source" "$target"
                echo "$target" >> "$LINKS_FILE"
                echo "Created: $rel_target -> $relative_source"
            fi
            linked=$((linked + 1))
        done < <(find "$PASSWORD_STORE_DIR" -name "*.gpg" -print0 | grep -zZ "/$real_path/")
    done < <(get_mappings)

    if [[ $linked -eq 0 ]]; then
        echo "No matching password store entries found"
    fi
}

link_remove() {
    local dry_run="${1:-false}"
    ensure_config_exists
    local removed=0

    while IFS=$'\t' read -r real_path alias; do
        while IFS= read -r -d '' link; do
            if [[ -L "$link" ]]; then
                if [[ "$dry_run" == "true" ]]; then
                    echo "[dry-run] Would remove: ${link#$PASSWORD_STORE_DIR/}"
                else
                    rm "$link"
                    echo "Removed: ${link#$PASSWORD_STORE_DIR/}"
                fi
                removed=$((removed + 1))
            fi
        done < <(find "$PASSWORD_STORE_DIR" -type l -name "*.gpg" -print0 2>/dev/null | grep -zZ "/$alias/")
    done < <(get_mappings)

    if [[ $removed -eq 0 ]]; then
        echo "No matching symlinks found"
    fi
}

link_undo() {
    local dry_run="${1:-false}"
    local count="${2:-0}"
    ensure_state_exists
    local removed=0
    local total_lines

    if [[ ! -s "$LINKS_FILE" ]]; then
        echo "No links to undo"
        return 0
    fi

    total_lines=$(wc -l < "$LINKS_FILE")
    if [[ "$count" -eq 0 || "$count" -gt "$total_lines" ]]; then
        count="$total_lines"
    fi

    local links_to_remove
    links_to_remove=$(tail -n "$count" "$LINKS_FILE")

    while IFS= read -r link; do
        if [[ -L "$link" ]]; then
            if [[ "$dry_run" == "true" ]]; then
                echo "[dry-run] Would undo: ${link#$PASSWORD_STORE_DIR/}"
            else
                rm "$link"
                echo "Undone: ${link#$PASSWORD_STORE_DIR/}"
            fi
            removed=$((removed + 1))
        fi
    done <<< "$links_to_remove"

    if [[ "$dry_run" != "true" ]]; then
        head -n "-$count" "$LINKS_FILE" > "$LINKS_FILE.tmp"
        mv "$LINKS_FILE.tmp" "$LINKS_FILE"
    fi

    if [[ $removed -eq 0 ]]; then
        echo "No links found to undo"
    fi
}

# Scrub functions

replace_on_directory_boundary() {
    local text="$1"
    local pattern="$2"
    local replacement="$3"
    local escaped_pattern
    escaped_pattern=$(printf '%s' "$pattern" | sed 's/[.[\*^$()+?{|\/]/\\&/g')
    printf '%s\n' "$text" | sed -E \
        -e "s|(pass )${escaped_pattern}([)\"' ])|\1${replacement}\2|g" \
        -e "s|(pass )${escaped_pattern}\$|\1${replacement}|g" \
        -e "s|(pass [\"'])${escaped_pattern}([\"'])|\1${replacement}\2|g" \
        -e "s|(pass [\"'][^\"']*/)(${escaped_pattern})(/[^\"']*[\"'])|\1${replacement}\3|g" \
        -e "s|(pass [\"'][^\"']*/)(${escaped_pattern})([\"'])|\1${replacement}\3|g" \
        -e "s|(pass [\"'])(${escaped_pattern})(/[^\"']*[\"'])|\1${replacement}\3|g" \
        -e "s|(pass [^\"' ]+/)(${escaped_pattern})(/[^)\"' ]+)|\1${replacement}\3|g" \
        -e "s|(pass [^\"' ]+/)(${escaped_pattern})([)\"' ])|\1${replacement}\3|g" \
        -e "s|(pass )(${escaped_pattern})(/[^)\"' ]+)|\1${replacement}\3|g"
}

scrub_file() {
    local file="$1"
    local dry_run="${2:-false}"
    local content
    content=$(cat "$file")
    local modified="$content"

    while IFS=$'\t' read -r real_path alias; do
        modified=$(replace_on_directory_boundary "$modified" "$real_path" "$alias")
    done < <(get_mappings)

    if [[ "$content" == "$modified" ]]; then
        return 0
    fi

    if [[ "$dry_run" == "true" ]]; then
        echo "=== $file ==="
        diff --color=auto <(echo "$content") <(echo "$modified") || true
    else
        echo "$modified" > "$file"
        echo "Updated: $file"
    fi
}

scrub_path() {
    local path="$1"
    local dry_run="${2:-false}"

    if [[ -f "$path" ]]; then
        scrub_file "$path" "$dry_run"
    elif [[ -d "$path" ]]; then
        while IFS= read -r -d '' file; do
            scrub_file "$file" "$dry_run"
        done < <(find "$path" -type f -print0)
    else
        echo "Path not found: $path" >&2
        return 1
    fi
}

# Command handlers

cmd_map() {
    local subcmd="${1:-}"
    shift || true

    case "$subcmd" in
        add)
            if [[ $# -lt 2 ]]; then
                echo "Usage: passonym map add <real-path> <alias>" >&2
                return 1
            fi
            map_add "$1" "$2"
            ;;
        remove)
            if [[ $# -lt 1 ]]; then
                echo "Usage: passonym map remove <alias>" >&2
                return 1
            fi
            map_remove "$1"
            ;;
        list)
            map_list
            ;;
        *)
            echo "Usage: passonym map <add|remove|list>" >&2
            return 1
            ;;
    esac
}

cmd_link() {
    local dry_run="false"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h) show_help; return 0 ;;
            --dry-run) dry_run="true"; shift ;;
            *) echo "Unknown option: $1" >&2; return 1 ;;
        esac
    done
    link_create "$dry_run"
}

cmd_unlink() {
    local dry_run="false"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h) show_help; return 0 ;;
            --dry-run) dry_run="true"; shift ;;
            *) echo "Unknown option: $1" >&2; return 1 ;;
        esac
    done
    link_remove "$dry_run"
}

cmd_undo() {
    local dry_run="false"
    local count=0
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h) show_help; return 0 ;;
            --dry-run) dry_run="true"; shift ;;
            [0-9]*) count="$1"; shift ;;
            *) echo "Unknown option: $1" >&2; return 1 ;;
        esac
    done
    link_undo "$dry_run" "$count"
}

cmd_scrub() {
    local dry_run="false"
    local path=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h) show_help; return 0 ;;
            --dry-run) dry_run="true"; shift ;;
            *)
                if [[ -z "$path" ]]; then
                    path="$1"
                else
                    echo "Unexpected argument: $1" >&2
                    return 1
                fi
                shift
                ;;
        esac
    done

    if [[ -z "$path" ]]; then
        echo "Usage: passonym scrub <file|dir> [--dry-run]" >&2
        return 1
    fi

    scrub_path "$path" "$dry_run"
}

show_help() {
    cat <<EOF
passonym - Anonymize password store references

Usage:
    passonym map add <real-path> <alias>   Add a mapping
    passonym map remove <alias>            Remove a mapping
    passonym map list                      List all mappings
    passonym link [--dry-run]              Create symlinks in password store
    passonym unlink [--dry-run]            Remove symlinks matching mappings
    passonym undo [N] [--dry-run]          Undo last N link operations (default: all)
    passonym scrub <file|dir> [--dry-run]  Anonymize pass references in files

Examples:
    passonym map add "john@work.com" "work-email"
    passonym link --dry-run
    passonym unlink --dry-run
    passonym undo 5
    passonym scrub ~/.config/mbsyncrc --dry-run
EOF
}

# Test functions

test_setup() {
    export CONFIG_DIR=$(mktemp -d)
    export MAPPINGS_FILE="$CONFIG_DIR/mappings.json"
    export STATE_DIR=$(mktemp -d)
    export LINKS_FILE="$STATE_DIR/links"
    export PASSWORD_STORE_DIR=$(mktemp -d)
    export TEST_DIR=$(mktemp -d)
}

test_teardown() {
    rm -rf "$CONFIG_DIR" "$STATE_DIR" "$PASSWORD_STORE_DIR" "$TEST_DIR"
}

test_map_add() {
    map_add "Email/test@example.com" "test-email" > /dev/null
    local result
    result=$(jq -r '.["Email/test@example.com"]' "$MAPPINGS_FILE")
    if [[ "$result" == "test-email" ]]; then
        echo "PASS: test_map_add"
    else
        echo "FAIL: test_map_add - expected 'test-email', got '$result'"
        return 1
    fi
}

test_map_remove() {
    map_add "Email/remove@example.com" "remove-me" > /dev/null
    map_remove "remove-me" > /dev/null
    local count
    count=$(jq 'length' "$MAPPINGS_FILE")
    if [[ "$count" -eq 0 ]]; then
        echo "PASS: test_map_remove"
    else
        echo "FAIL: test_map_remove - mapping still exists"
        return 1
    fi
}

test_map_list() {
    map_add "Path/one" "alias-one" > /dev/null
    map_add "Path/two" "alias-two" > /dev/null
    local count
    count=$(map_list | wc -l)
    if [[ "$count" -eq 2 ]]; then
        echo "PASS: test_map_list"
    else
        echo "FAIL: test_map_list - expected 2 lines, got $count"
        return 1
    fi
}

test_link_create() {
    mkdir -p "$PASSWORD_STORE_DIR/github.com/test@example.com"
    echo "encrypted" > "$PASSWORD_STORE_DIR/github.com/test@example.com/password.gpg"
    map_add "test@example.com" "test-alias" > /dev/null
    link_create "false" > /dev/null
    if [[ -L "$PASSWORD_STORE_DIR/github.com/test-alias/password.gpg" ]]; then
        echo "PASS: test_link_create"
    else
        echo "FAIL: test_link_create - symlink not created"
        return 1
    fi
}

test_link_dry_run() {
    mkdir -p "$PASSWORD_STORE_DIR/gitlab.com/user@test.com"
    echo "encrypted" > "$PASSWORD_STORE_DIR/gitlab.com/user@test.com/token.gpg"
    map_add "user@test.com" "my-user" > /dev/null
    link_create "true" > /dev/null
    if [[ ! -e "$PASSWORD_STORE_DIR/gitlab.com/my-user/token.gpg" ]]; then
        echo "PASS: test_link_dry_run"
    else
        echo "FAIL: test_link_dry_run - symlink should not exist in dry-run"
        return 1
    fi
}

test_unlink() {
    mkdir -p "$PASSWORD_STORE_DIR/example.com/user@test.com"
    echo "encrypted" > "$PASSWORD_STORE_DIR/example.com/user@test.com/password.gpg"
    map_add "user@test.com" "my-alias" > /dev/null
    link_create "false" > /dev/null
    if [[ ! -L "$PASSWORD_STORE_DIR/example.com/my-alias/password.gpg" ]]; then
        echo "FAIL: test_unlink - symlink not created"
        return 1
    fi
    link_remove "false" > /dev/null
    if [[ -e "$PASSWORD_STORE_DIR/example.com/my-alias/password.gpg" ]]; then
        echo "FAIL: test_unlink - symlink not removed"
        return 1
    fi
    echo "PASS: test_unlink"
}

test_undo() {
    mkdir -p "$PASSWORD_STORE_DIR/site.com/user@undo.com"
    echo "encrypted" > "$PASSWORD_STORE_DIR/site.com/user@undo.com/password.gpg"
    map_add "user@undo.com" "undo-alias" > /dev/null
    link_create "false" > /dev/null
    if [[ ! -L "$PASSWORD_STORE_DIR/site.com/undo-alias/password.gpg" ]]; then
        echo "FAIL: test_undo - symlink not created"
        return 1
    fi
    link_undo "false" "0" > /dev/null
    if [[ -e "$PASSWORD_STORE_DIR/site.com/undo-alias/password.gpg" ]]; then
        echo "FAIL: test_undo - symlink not undone"
        return 1
    fi
    echo "PASS: test_undo"
}

test_scrub_file() {
    map_add "Email/secret@company.com" "work" > /dev/null
    local test_file="$TEST_DIR/config"
    echo 'password = $(pass Email/secret@company.com)' > "$test_file"
    scrub_file "$test_file" "false"
    local result
    result=$(cat "$test_file")
    if [[ "$result" == 'password = $(pass work)' ]]; then
        echo "PASS: test_scrub_file"
    else
        echo "FAIL: test_scrub_file - got '$result'"
        return 1
    fi
}

test_scrub_dry_run() {
    map_add "Email/dry@test.com" "dry-alias" > /dev/null
    local test_file="$TEST_DIR/dryconfig"
    echo 'pass Email/dry@test.com' > "$test_file"
    scrub_file "$test_file" "true" > /dev/null
    local result
    result=$(cat "$test_file")
    if [[ "$result" == 'pass Email/dry@test.com' ]]; then
        echo "PASS: test_scrub_dry_run"
    else
        echo "FAIL: test_scrub_dry_run - file was modified in dry-run"
        return 1
    fi
}

test_scrub_quoted_paths() {
    map_add "Path/with spaces" "no-spaces" > /dev/null
    local test_file="$TEST_DIR/quoted"
    cat > "$test_file" <<'EOF'
double = $(pass "Path/with spaces")
single = $(pass 'Path/with spaces')
EOF
    scrub_file "$test_file" "false"
    local expected
    expected=$(cat <<'EOF'
double = $(pass "no-spaces")
single = $(pass 'no-spaces')
EOF
)
    local result
    result=$(cat "$test_file")
    if [[ "$result" == "$expected" ]]; then
        echo "PASS: test_scrub_quoted_paths"
    else
        echo "FAIL: test_scrub_quoted_paths"
        echo "Expected: $expected"
        echo "Got: $result"
        return 1
    fi
}

test_scrub_directory_boundary_middle() {
    map_add "john.doe@mail.com" "personal" > /dev/null
    local test_file="$TEST_DIR/boundary_middle"
    echo 'password = $(pass Email/john.doe@mail.com/password)' > "$test_file"
    scrub_file "$test_file" "false"
    local result
    result=$(cat "$test_file")
    if [[ "$result" == 'password = $(pass Email/personal/password)' ]]; then
        echo "PASS: test_scrub_directory_boundary_middle"
    else
        echo "FAIL: test_scrub_directory_boundary_middle - got '$result'"
        return 1
    fi
}

test_scrub_directory_boundary_start() {
    map_add "john.doe@mail.com" "personal" > /dev/null
    local test_file="$TEST_DIR/boundary_start"
    echo 'password = $(pass john.doe@mail.com/password)' > "$test_file"
    scrub_file "$test_file" "false"
    local result
    result=$(cat "$test_file")
    if [[ "$result" == 'password = $(pass personal/password)' ]]; then
        echo "PASS: test_scrub_directory_boundary_start"
    else
        echo "FAIL: test_scrub_directory_boundary_start - got '$result'"
        return 1
    fi
}

test_scrub_directory_boundary_end() {
    map_add "john.doe@mail.com" "personal" > /dev/null
    local test_file="$TEST_DIR/boundary_end"
    echo 'password = $(pass Email/john.doe@mail.com)' > "$test_file"
    scrub_file "$test_file" "false"
    local result
    result=$(cat "$test_file")
    if [[ "$result" == 'password = $(pass Email/personal)' ]]; then
        echo "PASS: test_scrub_directory_boundary_end"
    else
        echo "FAIL: test_scrub_directory_boundary_end - got '$result'"
        return 1
    fi
}

test_scrub_no_partial_directory_match() {
    map_add "john.doe" "personal" > /dev/null
    local test_file="$TEST_DIR/no_partial"
    echo 'password = $(pass Email/john.doe@mail.com)' > "$test_file"
    scrub_file "$test_file" "false"
    local result
    result=$(cat "$test_file")
    if [[ "$result" == 'password = $(pass Email/john.doe@mail.com)' ]]; then
        echo "PASS: test_scrub_no_partial_directory_match"
    else
        echo "FAIL: test_scrub_no_partial_directory_match - got '$result'"
        return 1
    fi
}

test_scrub_multi_directory_mapping() {
    map_add "Email/john.doe@mail.com" "personal-email" > /dev/null
    local test_file="$TEST_DIR/multi_dir"
    echo 'password = $(pass Email/john.doe@mail.com/password)' > "$test_file"
    scrub_file "$test_file" "false"
    local result
    result=$(cat "$test_file")
    if [[ "$result" == 'password = $(pass personal-email/password)' ]]; then
        echo "PASS: test_scrub_multi_directory_mapping"
    else
        echo "FAIL: test_scrub_multi_directory_mapping - got '$result'"
        return 1
    fi
}

run_tests() {
    local failed=0
    local tests=(
        test_map_add
        test_map_remove
        test_map_list
        test_link_create
        test_link_dry_run
        test_unlink
        test_undo
        test_scrub_file
        test_scrub_dry_run
        test_scrub_quoted_paths
        test_scrub_directory_boundary_middle
        test_scrub_directory_boundary_start
        test_scrub_directory_boundary_end
        test_scrub_no_partial_directory_match
        test_scrub_multi_directory_mapping
    )

    for test in "${tests[@]}"; do
        test_setup
        if ! $test; then
            ((failed++))
        fi
        test_teardown
    done

    echo ""
    if [[ $failed -eq 0 ]]; then
        echo "All ${#tests[@]} tests passed"
    else
        echo "$failed of ${#tests[@]} tests failed"
        return 1
    fi
}

# Main entry point

main() {
    local cmd="${1:-}"
    shift || true

    case "$cmd" in
        map)    cmd_map "$@" ;;
        link)   cmd_link "$@" ;;
        unlink) cmd_unlink "$@" ;;
        undo)   cmd_undo "$@" ;;
        scrub)  cmd_scrub "$@" ;;
        --test) run_tests ;;
        --help|-h|"") show_help ;;
        *)
            echo "Unknown command: $cmd" >&2
            show_help
            return 1
            ;;
    esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
